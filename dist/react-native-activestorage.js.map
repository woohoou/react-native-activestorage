{"version":3,"file":"react-native-activestorage.js","sources":["../src/lib/checksum.ts","../src/lib/directUpload.ts","../src/lib/createBlobRecord.ts","../src/Context.ts","../src/useDirectUpload.ts","../src/useConfig.ts","../src/lib/insertOrReplace.ts","../src/ActiveStorageProvider.tsx","../src/DirectUpload.tsx"],"sourcesContent":["import RNFetchBlob from 'rn-fetch-blob';\nimport { btoa } from 'abab';\n\nconst checksum = async ({ path }: { path: string }) => {\n  const md5 = await RNFetchBlob.fs.hash(path, 'md5');\n  const hexArray = md5.replace(/\\r|\\n/g, \"\")\n    .replace(/([\\da-fA-F]{2}) ?/g, \"0x$1 \")\n    .replace(/ +$/, \"\")\n    .split(\" \")\n    .map(it => parseInt(it));\n\n  const byteString = String.fromCharCode(...hexArray);\n\n  return btoa(byteString);\n}\n\nexport default checksum;\n","import RNFetchBlob, { FetchBlobResponse, StatefulPromise } from 'rn-fetch-blob';\nimport createBlobRecord from './createBlobRecord';\nimport { File, DirectUploadResult, HandleStatusUpdateData } from '../types';\n\nlet id = 0;\n\ninterface DirectUploadParams {\n  directUploadsUrl: string;\n  file: File;\n  headers?: object;\n  onStatusChange: (data: DirectUploadResult) => void;\n}\n\nconst directUpload = ({\n  directUploadsUrl,\n  file,\n  headers,\n  onStatusChange,\n}: DirectUploadParams) => {\n  const taskId = ++id;\n  let canceled = false;\n  let task: StatefulPromise<FetchBlobResponse>;\n\n  const handleCancel = () => {\n    if (!task) {\n      return;\n    }\n\n    canceled = true;\n    task.cancel();\n  };\n\n  const handleStatusUpdate = (data: HandleStatusUpdateData) => {\n    onStatusChange({ ...data, id: taskId, cancel: handleCancel, file });\n  };\n\n  handleStatusUpdate({ status: 'waiting' });\n\n  return new Promise<string | void>(async (resolve, reject) => {\n    try {\n      const blobData = await createBlobRecord({\n        directUploadsUrl,\n        file,\n        headers,\n      });\n      const { url, headers: uploadHeaders } = blobData.direct_upload;\n      const fileData = RNFetchBlob.wrap(file.path);\n      task = RNFetchBlob.fetch('PUT', url, uploadHeaders, fileData);\n      task\n        .uploadProgress({ interval: 250 }, (uploadedBytes, totalBytes) => {\n          const progress = (uploadedBytes / totalBytes) * 100;\n          handleStatusUpdate({\n            status: 'uploading',\n            progress,\n            totalBytes,\n            uploadedBytes,\n          });\n        })\n        .then((resp) => {\n          const status = resp.info().status;\n          if (status >= 200 && status < 400) {\n            handleStatusUpdate({ status: 'success' });\n            resolve(blobData.signed_id);\n          } else {\n            const error = new Error('Response not success');\n            handleStatusUpdate({\n              status: 'error',\n              error,\n            });\n            reject(error);\n          }\n        })\n        .catch((err) => {\n          if (canceled) {\n            handleStatusUpdate({ status: 'canceled' });\n          } else {\n            handleStatusUpdate({ status: 'error', error: err });\n          }\n\n          reject(err);\n        });\n    } catch (err) {\n      handleStatusUpdate({ status: 'error', error: err });\n      return reject(err);\n    }\n  });\n};\n\nexport default directUpload;\n","import getChecksum from './checksum';\nimport { File } from '../types';\n\ninterface CreateBlobRecordParams {\n  directUploadsUrl: string;\n  file: File;\n  headers?: object;\n}\n\ninterface BlobParams {\n  filename: string;\n  content_type: string;\n  byte_size: number;\n  checksum: string;\n  metadata?: object;\n}\n\nconst createBlobRecord = async ({ directUploadsUrl, file, headers = {} }: CreateBlobRecordParams) => {\n  const checksum = await getChecksum({ path: file.path });\n\n  if (!checksum) {\n    throw new Error(`Failed to get file checksum. Path: ${file.path}`)\n  }\n\n  const params: BlobParams = {\n    filename: file.name,\n    content_type: file.type || 'image/jpeg',\n    byte_size: file.size,\n    checksum,\n  }\n\n  if (file.metadata) {\n    params.metadata = file.metadata;\n  }\n\n  const response = await fetch(directUploadsUrl, {\n    method: 'POST',\n    body: JSON.stringify({ blob: params }),\n    headers: { 'Content-Type': 'application/json', ...headers },\n  });\n\n  return response.json();\n}\n\nexport default createBlobRecord;\n","import { createContext } from 'react';\n\ntype Headers = {\n  [key: number]: string;\n}\n\ntype ContextType = {\n  host: string;\n  mountPath?: string;\n  headers?: Headers;\n}\n\nconst defaultContext = {\n  host: 'http://localhost:3000',\n  mountPath: '/rails/active_storage',\n  headers: {}, \n};\n\nexport const Context = createContext<ContextType>(defaultContext);\nexport const { Consumer, Provider } = Context;\n\nexport default Context;\n","import { useMemo, useState, useCallback } from 'react';\nimport { File, DirectUploadResult } from './types';\nimport directUpload from './lib/directUpload';\nimport insertOrReplace from './lib/insertOrReplace';\nimport useConfig from './useConfig';\n\ninterface OnSuccessParams {\n  signedIds: string[];\n}\n\nexport type Params = {\n  onSuccess?: (params: OnSuccessParams) => void;\n  onError?: (params: unknown) => void;\n};\n\nconst useDirectUpload = ({ onSuccess, onError }: Params = {}) => {\n  const { directUploadsUrl, headers } = useConfig();\n  const [uploads, setUploads] = useState<DirectUploadResult[]>([]);\n\n  const handleFileUploadChange = useCallback(\n    (fileUpload: DirectUploadResult) => {\n      setUploads((fileUploads) => insertOrReplace(fileUploads, fileUpload));\n    },\n    []\n  );\n\n  const upload = useCallback(\n    async (files: File[]) => {\n      try {\n        const signedIds = await Promise.all(\n          files.map((file) =>\n            directUpload({\n              file,\n              directUploadsUrl,\n              headers,\n              onStatusChange: handleFileUploadChange,\n            })\n          )\n        );\n\n        const validIds = signedIds.filter((it) => !!it) as string[];\n        if (validIds.length > 0) {\n          onSuccess && onSuccess({ signedIds: validIds });\n        }\n\n        return { signedIds: validIds };\n      } catch (err) {\n        onError && onError(err);\n        return {};\n      }\n    },\n    [directUploadsUrl, headers, handleFileUploadChange, onSuccess, onError]\n  );\n\n  const uploading = useMemo(\n    () => uploads.some((upload) => upload.status === 'uploading'),\n    [uploads]\n  );\n\n  return {\n    upload,\n    uploads,\n    uploading,\n  };\n};\n\nexport default useDirectUpload;\n","import { useContext } from 'react';\nimport Context from './Context';\n\nconst useConfig = () => {\n  const config = useContext(Context);\n\n  const mountPath = config.mountPath || '/rails/active_storage';\n\n  const url = `${config.host}${mountPath}`;\n\n  return {\n    ...config,\n    mountPath,\n    directUploadsUrl: `${url}/direct_uploads`,\n  };\n};\n\nexport default useConfig;\n","type Item = { [key: string]: any };\n\nconst insertOrReplace = <T extends Item>(list: T[], obj: T, key = 'id') => {\n  const newList = [...list];\n  const index = newList.findIndex((it) => it[key] === obj[key]);\n\n  if (index >= 0) {\n    newList[index] = obj;\n  } else {\n    newList.push(obj);\n  }\n\n  return newList;\n};\nexport default insertOrReplace;\n","import React from 'react';\nimport { Provider } from './Context';\n\ntype Headers = {\n  [key: number]: string;\n};\n\ntype Props = {\n  host: string;\n  mountPath?: string;\n  headers?: Headers;\n};\n\nconst ActiveStorageProvider: React.FC<Props> = ({\n  host,\n  mountPath,\n  headers,\n  children,\n}) => <Provider value={{ host, mountPath, headers }}>{children}</Provider>;\n\nexport default ActiveStorageProvider;\n","import { ReactNode } from 'react';\nimport useDirectUpload, { Params } from './useDirectUpload';\n\ntype Props = {\n  children: (data: ReturnType<typeof useDirectUpload>) => ReactNode;\n} & Params;\n\nconst DirectUpload = ({ children, onSuccess, onError }: Props) => {\n  const data = useDirectUpload({ onSuccess, onError });\n\n  return children(data);\n};\n\nexport default DirectUpload;\n"],"names":["checksum","path","RNFetchBlob","fs","hash","md5","hexArray","replace","split","map","it","parseInt","byteString","String","fromCharCode","btoa","id","directUpload","task","directUploadsUrl","file","headers","onStatusChange","taskId","canceled","handleCancel","cancel","handleStatusUpdate","data","status","Promise","resolve","reject","getChecksum","Error","params","filename","name","content_type","type","byte_size","size","metadata","fetch","method","body","JSON","stringify","blob","Content-Type","response","json","createBlobRecord","blobData","direct_upload","url","uploadHeaders","fileData","wrap","uploadProgress","interval","uploadedBytes","totalBytes","progress","then","resp","info","signed_id","error","err","Context","createContext","host","mountPath","Provider","useDirectUpload","config","onSuccess","onError","useContext","useState","uploads","setUploads","handleFileUploadChange","useCallback","fileUpload","fileUploads","list","obj","key","newList","index","findIndex","push","insertOrReplace","upload","files","all","signedIds","validIds","filter","length","uploading","useMemo","some","React","value","children"],"mappings":"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"}